<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Pie Chart Generator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple transition for hover effects */
        .btn-hover {
            transition: all 0.2s ease-in-out;
        }
        .btn-hover:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        /* Style for the legend delete button */
        .delete-btn {
            opacity: 0.5;
            transition: all 0.2s ease;
        }
        .delete-btn:hover {
            opacity: 1;
            color: #ef4444; /* red-500 */
            transform: scale(1.1);
        }
        /* Custom scrollbar for legend */
        .legend-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .legend-scroll::-webkit-scrollbar-track {
            background: #f1f5f9; /* slate-100 */
            border-radius: 10px;
        }
        .legend-scroll::-webkit-scrollbar-thumb {
            background: #94a3b8; /* slate-400 */
            border-radius: 10px;
        }
        .legend-scroll::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* slate-500 */
        }
        /* Hide file input */
        #file-upload {
            display: none;
        }
        /* Style for file upload label */
        .file-upload-label {
            cursor: pointer;
            display: block;
            text-align: center;
        }
    </style>
    <!-- Import Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-slate-100 min-h-screen flex items-center justify-center p-4">

    <div class="w-full max-w-4xl bg-white rounded-2xl shadow-2xl p-6 md:p-8 flex flex-col lg:flex-row gap-6 md:gap-8">

        <!-- Left Side: Inputs & Legend -->
        <div class="w-full lg:w-1/3 flex flex-col">
            <h1 class="text-2xl font-bold text-slate-800 mb-4">Chart Data</h1>
            
            <!-- Input Form -->
            <form id="chart-form" class="space-y-4 mb-6">
                <div>
                    <label for="entry-name" class="block text-sm font-medium text-slate-600 mb-1">Entry Name</label>
                    <input type="text" id="entry-name" placeholder="e.g., Developer Owned" class="w-full px-4 py-2 border border-slate-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" required>
                </div>
                <div>
                    <label for="entry-value" class="block text-sm font-medium text-slate-600 mb-1">Percentage</label>
                    <input type="number" id="entry-value" placeholder="e.g., 50" min="0" step="any" class="w-full px-4 py-2 border border-slate-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" required>
                    <!-- UPDATED: Helper text -->
                    <p class="text-xs text-slate-500 mt-1">Enter a % (e.g., 50 for 50%). Child values are a % *of their parent*.</p>
                </div>
                <!-- Parent Dropdown -->
                <div>
                    <label for="entry-parent" class="block text-sm font-medium text-slate-600 mb-1">Parent Entry</label>
                    <select id="entry-parent" class="w-full px-4 py-2 border border-slate-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        <option value="none">None (Top Level)</option>
                        <!-- Parent options will be injected here -->
                    </select>
                </div>
                <button type="submit" class="w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md btn-hover">
                    Add Entry
                </button>
            </form>

            <!-- File Upload Section -->
            <div class="border-t pt-4 mb-4">
                <h3 class="text-lg font-semibold text-slate-700 mb-2">Bulk Upload</h3>
                <input type="file" id="file-upload" accept=".csv">
                <label for="file-upload" class="file-upload-label w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md btn-hover">
                    Upload CSV File
                </label>
                <p class="text-xs text-slate-500 mt-2">CSV format: `Name,Value,ParentName` (no header row). `ParentName` must match an existing entry's name.</p>
            </div>

            <!-- Legend -->
            <h2 class="text-lg font-semibold text-slate-700 mb-3 border-b pb-2">Legend</h2>
            <div id="legend" class="flex-grow space-y-1 overflow-y-auto max-h-60 lg:max-h-[300px] legend-scroll pr-2">
                <p id="legend-placeholder" class="text-slate-500 text-sm">Add data to see the legend.</p>
            </div>

            <!-- Action Buttons -->
            <div class="flex-shrink-0 pt-4 border-t mt-4 space-y-2">
                <button id="download-png" class="w-full bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md btn-hover">
                    Download as PNG
                </button>
                <button id="clear-chart" class="w-full bg-red-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md btn-hover">
                    Clear Chart
                </button>
            </div>
        </div>

        <!-- Right Side: Pie Chart -->
        <div class="w-full lg:w-2/3 flex items-center justify-center bg-slate-50 rounded-lg p-4 min-h-[300px] lg:min-h-[450px]">
            <canvas id="pie-chart"></canvas>
            <p id="chart-placeholder" class="text-slate-500 text-lg">Your chart will appear here</p>
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('pie-chart');
        const ctx = canvas.getContext('2d');
        const form = document.getElementById('chart-form');
        const nameInput = document.getElementById('entry-name');
        const valueInput = document.getElementById('entry-value');
        const parentSelect = document.getElementById('entry-parent');
        const legend = document.getElementById('legend');
        const legendPlaceholder = document.getElementById('legend-placeholder');
        const chartPlaceholder = document.getElementById('chart-placeholder');
        const clearButton = document.getElementById('clear-chart');
        const fileInput = document.getElementById('file-upload');
        const downloadButton = document.getElementById('download-png');

        // --- State ---
        let chartData = []; 
        // { id, name, userValue (0-100), calcFraction (0-1), remainingFraction (0-1), children: [] }

        const colors = [
            '#3b82f6', '#ec4899', '#10b981', '#f59e0b', '#8b5cf6',
            '#ef4444', '#14b8a6', '#6366f1', '#d946ef', '#0ea5e9',
            '#f43f5e', '#22c55e', '#84cc16', '#eab308', '#6d28d9'
        ];
        // Special color for "Unallocated"
        const unallocatedColor = '#94a3b8'; // slate-400
        const floatErrorMargin = 1e-9; // For floating point comparisons

        // --- Helper Functions ---

        function getColor(index) {
            return colors[index % colors.length];
        }

        function getTextColor(hexColor) {
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return (yiq >= 128) ? '#0f172a' : '#ffffff';
        }

        function findNode(id, nodes = chartData) {
            for (const node of nodes) {
                if (node.id === id) return node;
                const found = findNode(id, node.children);
                if (found) return found;
            }
            return null;
        }

        function findNodeByName(name, nodes = chartData) {
            for (const node of nodes) {
                if (node.name === name) return node;
                const found = findNodeByName(name, node.children);
                if (found) return found;
            }
            return null;
        }

        /**
         * Recursively recalculates values based on parent's fraction.
         */
        function recalculateValues(node, parentFraction) {
            // This node's *total* fraction of the pie
            node.calcFraction = parentFraction * (node.userValue / 100.0);
            
            let childrenFractionSum = 0;
            if (node.children.length > 0) {
                node.children.forEach(child => {
                    // A child's value is a percentage *of this node's* calculated fraction
                    childrenFractionSum += recalculateValues(child, node.calcFraction);
                });
            }
            
            // This node's remaining portion
            node.remainingFraction = node.calcFraction - childrenFractionSum;
            
            // Return this node's *total* calculated fraction to its parent
            return node.calcFraction; 
        }

        /**
         * Runs recalculation on the entire tree.
         */
        function updateAllCalculatedValues() {
            // Top-level nodes are children of the "root" (1.0 = 100%)
            chartData.forEach(node => recalculateValues(node, 1.0));
        }

        /**
         * Renders the legend in the DOM, now recursively.
         */
        function renderLegend() {
            legend.innerHTML = '';
            if (chartData.length === 0) {
                legend.appendChild(legendPlaceholder);
                return;
            }
            buildLegendDOM(chartData, legend, 0);
        }

        /**
         * Recursive helper for building the legend DOM.
         */
        function buildLegendDOM(nodes, container, level) {
            nodes.forEach((item, index) => {
                const percentage = item.calcFraction * 100;
                // Top-level items get a color
                const color = level === 0 ? getColor(index) : 'transparent';

                const li = document.createElement('div');
                li.className = 'flex items-center justify-between p-2 rounded-lg hover:bg-slate-50';
                li.style.marginLeft = `${level * 20}px`;
                
                li.innerHTML = `
                    <div class="flex items-center gap-3">
                        <span class="w-4 h-4 rounded-full border border-slate-200" style="background-color: ${color}"></span>
                        <span class="font-medium text-slate-700">${item.name}</span>
                    </div>
                    <div class="flex items-center gap-3">
                        <span class="text-sm text-slate-500" title="Value: ${item.userValue}%">${percentage.toFixed(1)}%</span>
                        <button class="delete-btn" data-id="${item.id}" title="Delete Entry">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                        </button>
                    </div>
                `;
                container.appendChild(li);

                // Recursively render children
                if (item.children.length > 0) {
                    buildLegendDOM(item.children, container, level + 1);
                    // Show this parent's remaining (unallocated) portion
                    if (item.remainingFraction > floatErrorMargin) {
                        const remainingPercentage = item.remainingFraction * 100;
                        const remainingLi = document.createElement('div');
                        remainingLi.className = 'flex items-center justify-between p-2 rounded-lg';
                        remainingLi.style.marginLeft = `${(level + 1) * 20}px`;
                        remainingLi.innerHTML = `
                            <div class="flex items-center gap-3">
                                <span class="w-4 h-4 rounded-full border border-slate-200" style="background-color: transparent"></span>
                                <span class="font-medium text-slate-500 italic">${item.name} (Unallocated)</span>
                            </div>
                            <div class="flex items-center gap-3">
                                <span class="text-sm text-slate-500">${remainingPercentage.toFixed(1)}%</span>
                            </div>
                        `;
                        container.appendChild(remainingLi);
                    }
                }
            });
        }
        
        /**
         * Gets a flat list of all slices to draw (leaf nodes and remaining parent portions).
         */
        function getNodesToDraw(nodes) {
            let nodesToDraw = [];
            nodes.forEach((node, index) => {
                if (node.children.length === 0) {
                    // Leaf node, draw it with its color
                    if (node.calcFraction > floatErrorMargin) {
                        nodesToDraw.push({
                            name: node.name,
                            fraction: node.calcFraction,
                            color: getColor(index) // Color based on top-level index
                        });
                    }
                } else {
                    // Parent node, draw its *remaining* part
                    if (node.remainingFraction > floatErrorMargin) {
                        nodesToDraw.push({
                            name: `${node.name} (Unallocated)`,
                            fraction: node.remainingFraction,
                            color: getColor(index) // Color based on top-level index
                        });
                    }
                    // Recurse to get children
                    nodesToDraw = nodesToDraw.concat(getNodesToDraw(node.children));
                }
            });
            return nodesToDraw;
        }

        /**
         * Renders the pie chart.
         */
        function renderChart() {
            // Get a flat list of all drawable slices
            const renderData = getNodesToDraw(chartData);
            
            // Calculate total allocated fraction
            let totalFraction = renderData.reduce((sum, item) => sum + item.fraction, 0);

            if (totalFraction < (1.0 - floatErrorMargin)) {
                // Add the main "Unallocated" slice
                renderData.push({
                    name: 'Unallocated',
                    fraction: 1.0 - totalFraction,
                    color: unallocatedColor
                });
            }
            
            if (renderData.length === 0 || totalFraction < floatErrorMargin) {
                chartPlaceholder.style.display = 'block';
                canvas.style.display = 'none';
                return;
            }

            chartPlaceholder.style.display = 'none';
            canvas.style.display = 'block';

            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, container.clientHeight) * 0.9;
            canvas.width = size;
            canvas.height = size;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.9;

            let startAngle = -0.5 * Math.PI;
            // The total is always 1.0 (100%)
            const total = 1.0; 

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            renderData.forEach((item, index) => {
                // Slice angle is its fraction of the *total* pie (which is 1.0)
                const sliceAngle = (item.fraction / total) * 2 * Math.PI;
                const endAngle = startAngle + sliceAngle;
                const color = item.color; // Use the pre-assigned color

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();

                // Draw percentage text
                if (item.fraction > 0.04) { // 4% threshold
                    const textAngle = startAngle + sliceAngle / 2;
                    const textRadius = radius * 0.65;
                    const textX = centerX + textRadius * Math.cos(textAngle);
                    const textY = centerY + textRadius * Math.sin(textAngle);
                    
                    const percentage = item.fraction * 100;
                    
                    ctx.fillStyle = getTextColor(color);
                    ctx.font = 'bold 14px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(item.name, textX, textY - 8);
                    ctx.font = '12px Inter';
                    ctx.fillText(`${percentage.toFixed(1)}%`, textX, textY + 10);
                }
                startAngle = endAngle;
            });
        }


        /**
         * Recursively populates the Parent dropdown.
         */
        function updateParentDropdown() {
            parentSelect.innerHTML = '<option value="none">None (Top Level)</option>';
            buildParentOptions(chartData, parentSelect, 0);
        }

        function buildParentOptions(nodes, select, level) {
            nodes.forEach(node => {
                const option = document.createElement('option');
                option.value = node.id;
                option.textContent = `${'â€”'.repeat(level)} ${node.name}`;
                select.appendChild(option);
                if (node.children.length > 0) {
                    buildParentOptions(node.children, select, level + 1);
                }
            });
        }

        /**
         * Recursively deletes a node by ID.
         */
        function deleteNode(id, nodes) {
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].id === id) {
                    nodes.splice(i, 1);
                    return true;
                }
                if (deleteNode(id, nodes[i].children)) return true;
            }
            return false;
        }

        /**
         * Main UI update function.
         */
        function updateUI() {
            updateAllCalculatedValues();
            renderChart();
            renderLegend();
            updateParentDropdown();
        }

        // --- Event Handlers ---

        function handleAddEntry(e) {
            e.preventDefault();
            const name = nameInput.value.trim();
            const value = parseFloat(valueInput.value);
            const parentId = parentSelect.value;

            if (!name) {
                console.warn('Name is required.');
                nameInput.focus();
                return;
            }
            if (isNaN(value) || value < 0) {
                console.warn('Value must be a positive number.');
                valueInput.focus();
                return;
            }

            const newItem = {
                id: crypto.randomUUID(),
                name: name,
                userValue: value,
                calcFraction: 0, // Will be set by recalculate
                remainingFraction: 0, // Will be set by recalculate
                children: []
            };

            if (parentId === 'none') {
                chartData.push(newItem);
            } else {
                const parentNode = findNode(parentId);
                if (parentNode) {
                    parentNode.children.push(newItem);
                } else {
                    chartData.push(newItem); // Failsafe
                }
            }

            nameInput.value = '';
            valueInput.value = '';
            parentSelect.value = 'none';
            nameInput.focus();

            updateUI();
        }

        function handleLegendClick(e) {
            const deleteButton = e.target.closest('.delete-btn');
            if (deleteButton) {
                const idToDelete = deleteButton.dataset.id;
                deleteNode(idToDelete, chartData);
                updateUI();
            }
        }

        function handleClearChart() {
            chartData = [];
            updateUI();
        }

        /**
         * Handles CSV file upload.
         */
        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const csvText = event.target.result;
                parseCSV(csvText);
                fileInput.value = ''; // Reset file input
            };
            reader.readAsText(file);
        }

        /**
         * Parses CSV text and populates chartData.
         * Format: Name,Value,ParentName
         */
        function parseCSV(csvText) {
            try {
                const lines = csvText.split('\n').filter(line => line.trim() !== '');
                const flatData = [];
                const nodeMap = {}; // Maps name to node

                // Create all nodes first
                lines.forEach(line => {
                    const [name, value, parentName] = line.split(',').map(s => s.trim());
                    const val = parseFloat(value);
                    if (!name || isNaN(val)) return; // Skip invalid lines
                    
                    const node = {
                        id: crypto.randomUUID(),
                        name: name,
                        userValue: val,
                        calcFraction: 0,
                        remainingFraction: 0,
                        children: [],
                        parentName: parentName || null
                    };
                    flatData.push(node);
                    nodeMap[name] = node;
                });

                // Link nodes into a tree
                const newChartData = [];
                flatData.forEach(node => {
                    if (node.parentName && nodeMap[node.parentName]) {
                        nodeMap[node.parentName].children.push(node);
                    } else {
                        newChartData.push(node); // Add as top-level
                    }
                });

                chartData = newChartData;
                updateUI();
            } catch (error) {
                console.error("Error parsing CSV:", error);
                // In a real app, show a user-friendly error modal here
            }
        }

        /**
         * Handles chart download as PNG.
         */
        function handleDownload() {
            const link = document.createElement('a');
            link.download = 'pie_chart.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // --- Event Listeners ---
        form.addEventListener('submit', handleAddEntry);
        legend.addEventListener('click', handleLegendClick);
        clearButton.addEventListener('click', handleClearChart);
        fileInput.addEventListener('change', handleFileUpload);
        downloadButton.addEventListener('click', handleDownload);
        
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(updateUI, 100);
        });

        // --- Initial Render ---
        updateUI();

    </script>
</body>
</html>
